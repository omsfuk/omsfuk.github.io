-----------------------
title: Linux就是这个范 之 入门
tags: linux,读书笔记
-----------------------

# Linux系统


## Linux是一个多用户，多任务，分时操作系统
Linux操作系统j经历了如下几个阶段：没有操作系统 -> 失败的Multics -> Unix -> Linux
分时：将电脑中的时间资源适当的分配到所有的使用者身上。
多任务：对于一个分时操作系统，支持多任务是其与生俱来的素质
多用户：一个多用户操作系统，有时候提供单用户模式还是必要的，所谓单用户模式，就是操作系统不去确认用户的身份，可以直接让用户进行各种操作。但是存在安全问题。但是，这种方式可以进行系统修复，找回数据。

## 用户身份
#### 用户管理的内容：用户的身份等级和用户对文件的访问权。
#### 权限分类
* 权限（或者称为身份）只有两种：
 * root
 * 非root

无论用户名多NB(例如admin)，只要不是root，就是普通用户，权限都是一样的（要明白权限与文件访问权是不一样的）
除了home/[username]目录，其他都是公共目录，一般都是只读的。只有少数位置能够写入数据。
些特殊用户（如admin、nobody）不设置密码，即可以任意登录，但不会引发安全问题，因为权限都很小。
#### 配置文件
* 目录
`/etc/passwd` 用户。然而密码并不在这，即时在这，也不会是明文。。

* 保存格式
`用户名`:`密码`:`UID`:`GID`:`用户全名`:`home目录`:`Shell`
其中UID和GID中的0都是root用的，在CentOS7中，自建用户的UID和GID从1000开始。

#### 管理用户

* 添加用户：`useradd（adduser）`
通过如下命令可以添加一个用户omsfuk
```
useradd omsfuk
passwd omsfuk
```
会创建：Shell、home、uid，gid

* 删除用户
`userdel -r`连同目录一起删除

* 特殊用户：sudoer
CentOS中的新建用户默认不是sudoer，需要手动添加
`/etc/sudoers`
```
omsfuk ALL=(ALL) ALL//赋予所有权限
omsfuk ALL=(ALL) ALL, !/usr/sbin/adduser, !/usr/sbin/userdel //除去某些权限
```

#### 用户身份切换
su命令是用来做用户身份切换的，默认是root
使用`sudo su`可以用自己的密码切换到root，所以要在soders文件中禁止su被sudo特权调用。

#### 用户组管理
`groupadd`
`groupmod`
`groupdel`

#### 实际用户（组）有效用户（组）
一般情况下，实际用户和有效用户是相同的，只有发生用户身份切换的时候才会有差异
* `whoami`
* `who`能够识别真正身份
* `who am i`能够识别真正身份

## 文件与权限
Linux多用户权限控制的本质，实际上就是让不同的用户能够访问的文件不同罢了。
`-rwxr-xr-x 1 root root 27776 Apr 17 2012 arch`
从左到右依次为
* 文件类型：有`-dlbcsp`等几种（目录也是文件）
* rwxr-xr-x 依次为所有者，用户组，其他人的权限
* 连接数
* 所有者
* 所属组
* 创建日期
* 文件名

inode是所有类Unix操作系统中的一种数据结构，也是这类操作系统中文件系统的核心。系统通过inode定位每一个文件，而不文件名。

文件权限还有`s`、`t`两个特殊的。
`s`这个标记出现在文件拥有者（组）的`x`位置上，称为`SUID`、`SGID`权限
使用`ls -l /bin/su`可以查看下`su`命令的文件权限是`-rwsr-xr-x`
`SUID`仅对二进制文件有效，执行者杜宇改程序具有x的可执行权限。执行权限仅在执行程序的过程中有效。执行者将具有改程序拥有者的权限。这也是su命令能够切换用户的实现原理。
`SUID`很常见，那些需要提供给普通用户，但是又需要root权限才能正确执行的程序基本上都拥有SUID，比如`passwd`、`mount`命令。这也是实际用户和有效用户发生不一致的触发条件。`SUID`的典型是`locate`。是期望任何用户在执行这个命令的时候，能够读取`mlocate.db`文件的内容。

可以通过`u+s`来赋予`s`权限

`t`是针对于Other的`s`，仅对目录有效。
通过`o+t`赋予
在此目录下创建的文件，只有root和用户能够删除。典型的例子是`/tmp`目录。

#### 软连接与硬链接
`ln -s`软连接
`ln`硬连接
硬连接要求必须与目标文件在同一个分区中
软连接可以创建在任何位置，包括网络
软连接和硬连接使用的时候差别不大，都是相当于一个文件具有不同的路径和文件名
同一个文件拥有不同的路径，还能防止恶意删除
修改文件名并不会改变文件的最后修改时间
用`touch`可以改变文件修改时间

#### 文件操作
###### 特殊的目录名`-`、`~`、`.`、`..`
*  `.`、`..`就是文件硬连接的例子
* 由于`.`的存在，使得每一个目录的连接数都是2
* 由于`..`的存在，目录中每增加一个子目录，其连接数属性+1
* 目录`-`、`~`从未出现在磁盘中，他们实际上是`cd`命令的一个特殊参数，`-`代表一个工作目录，`~`则代表当前用户的home

###### 常用命令
`ls`
`cd`
`cp`
`rm`
`mv`移动文件/改名
###### 修改所有着（组）
`chown [-R] username:group filename`//更改拥有者（组）
`chown [-R] username filename`
但是无法改变文件类型（这里指的是Linux文件类型，Linux的文件类型是`-dlbcsp`)

###### 修改访问权限
`chmod 700 .bashrc`
`chmod u+x .bashrc`
`u`、`g`、`o`、`a`分别对应所有者，所有组，其他，所有

#### 搜索文件
* `whereis`快速，是在一个数据库`（/var/lib/mlocate）`中查询。每天通过自动执行`updatedb`更新一次，所有有时候查找不准确（当然你也可以手动更新，但是那就失去了高效的意义）。且只能用于搜索可执行文件，联机帮助文档和源代码文件。
* `locate`此命令使用了与`whereis`相同的数据库，但是使用了十分复杂的匹配语法。
`locate ls`可以列举无论是路径中出现`ls`还是文件名中出现`ls`
* `which`是更为常用的搜索命令。只是在`$PATH`环境变量中指定的路径来搜索可执行文件。
* `type`是用来判断一个命令是不是shell内置的。但是如果是非内置的，并使用了`type -p`,type就相当于which命令了
* `find`查询最慢，但是十分十分强大，它提供了精确的查询条件。精通的话要花大量时间。
```
find / -mtime 3 # 查询三天前那天发生变化的所有文件。
find / -mtime -3 # 查询三天内发生变化的所有文件
find / -mtime +3 # 查询三天以前发生变化的文件
find / -mtime -1 exec ls -l {} \;列出一天内变化的文件的信息
```

#### 对文件打包压缩
* 压缩比从低到高gz < bz2 < xz
* 速度 gz > bz2 > xz
```
解压文件
tar -vx -f filename
tar -vxf filename
压缩文件
tar -zcvf filename//gz
tar -jcvf filename//bz2
tar -Jcfv filename//xz
多出来的一个参数是压缩算法
```

`dump`、`restore`一对备份还原工具
`cpio`用来备份任何东西，也能实现文件打包
`cpio`还是一个十分特别的程序，即它所打包的文件名不是利用命令选项提供的，而是通过标准输入传递的，最终产生的输出文件会直接输出到标准输出。
```
find ... | cpio -ocB > filename # 打包
cpio -idc < filename # 解包
```
## 多任务
在图形界面下多任务自然不是问题，关键是在命令行下面实现多任务。
直接敲入命令并不会导致命令的执行（假定此命令在这个目录下），shell只会在$PATH中查找，所以必须要用路径（例如`./start.sh`）
Linux不需要拓展名来决定文件的可执行性，所以可以忽略所谓的扩展名。
多个命令程序同时执行，多任务可协调，多个任务之间是能够互帮互助的。
两个命令之间的竖线`|`就是起这种协调作用的，比较专业的称呼叫管道符。而这种程序直接的协调技术也被称为管道。更为专业的名称叫匿名管道。

#### 管道
 * 匿名管道
 * 命名管道（适合不同进程协作）

 管道只能从一端读入，从另一端读取。而且读入的顺序和写入的顺序是相同的。所以管道也叫FIFO。
 匿名和命名的区别，就是临时工和正式工之间的区别。
 通过`mkfifo`创建命名管道。**管道的文件类型为p**
 
#### IO重定向
IO重定向也是Linux提供的一种多任务协调机制。由于命名管道也是创建了具体的文件，所以使用命名管道时要对其进行读写使应该使用显式的IO重定向。

#### 流式处理
```
打包
find /boot | cpio -ocB | gzip -9 > tmp/boot.img
解包
cpio -idc < /tmp/boot.img # 未压缩过
gzip -dc /tmp/boot.img | cpio -idc # 压缩过
```

#### 前后台任务
* 将当前任务切换成后台任务
` Ctrl + z + bg`
* 在命令末尾添加`&`可以直接创建
* 使用jobs查看后台任务
* 带有`+`是默认不带参数切换到前台的任务
* `fg`可以将任务切换到前台。
* 使用`kill -9 %2`来关闭后台任务。其中2是任务号
只要你退出了终端，与其关联的所有任务都会被干掉，无论前后台。
使用`nohup [命令与参数] &`，这样命令所有的输出都会输出到nohup.out这个文件中，不过这个任务就不再与你的终端有什么关系。

虽然，Linux进行多任务使用与切换的方法要比Windows等图形界面上的体验差很多，但在执行少量任务的时候还是比较方便的。它是从正面鼓励你使用流式方式执行程序的。所以要很好的掌握管道和IO重定向的技巧。

#### 计划任务
###### 一次性计划任务
```
at 10:00 tomorrow #输入完成后换行，会提示
> # 此处输入命令，用Ctrl + D保存，会显示job | at 2012-12-20 10:00
```
用全路径来执行计划任务是一个好习惯，平时是因为有`$PATH`变量，但在计划任务中，没有`$PATH`的情况很常见。
在Linux中，`Ctrl + D`表示EOF。
可以用IO重定向将命令发送给`at`

###### 周期性计划任务cron
```
crontab -e 编辑当前用户cron表
crontab -l 查看当前用户的cron表
crontab -u 用户名，以某用户的身份来控制cron表
```
分为两列：时间+命令
能否添加到计划任务由4个文件指定。`at.allow`、`at.deny`、`cron.allow`、`cron.deny`

#### 守护进程及其作用
Linux服务器在启动时要启动很多的系统服务（其实Windows也是这样），它们向本地或网络用户提供了Linux的系统功能接口，直接面向程序和用户。提供这些服务的程序就是由守护进程实现的。
守护进程是生存期很长的一种进程。
它们独立于控制终端，并且周期性地执行某任务或等待处理某些发生的事件。
使用`nysysv`命令（RedHat或CentOS）可以查看守护线程。需要root权限。

守护进程分两类
* stand clone 独立启动，响应最快，一直占用资源。
守护进程的启动脚本在`/etc/init.d`目录下。实际上CentOS中的init.d只是一个符号连接。
* xinetd 依托于一个统一的stand alone守护进程，这个进程被称为Super Daemon）
赋予了Super Daemon安全控制的机制。客户端的联机结束后就关闭，不会一直占用系统资源。
启动脚本在/etc/xinetd.d目录下。设置disable属性可以控制是否需要开启（它是按需启动的，请求的时候才启动）

## 进程管理
三个命令`ps`、`top`、`pstree`
#### ps
`ps aux` 查看系统中所有程序的数据
`ps ux` 查看当前用户所有程序的数据
`ps -l`查看与当前终端关联的程序数据
有的有`-`，有的没有。。。。
只需要记住这三个常用的就好了
#### top
top每5秒刷新一次
`top -d 2 -p 12201`分别设置刷新间隔和监视的进程ID
#### pstree
查看进程的父子祖先关系

## 软件安装方式
#### 从源代码安装
三步走：`configure`、`make`、`make install`
这种软件安装方式因为没有做软件相关性检查，导致它依赖的其他软件不存在或或者版本不正确，从而有可能无法正常运行。
#### 软件管理工具：rpm、dpkg
软件发行商需要在固定的操作系统平台上将需要安装或升级的软件及其相关的软件打包称一个特殊格式的文件。这个软件包含了软件包描述文件。其提供了软件包的各种信息，例如软件包的名字，版本，类别，说明摘要等。创建时需要执行什么指令。安装时要执行什么操作，以及软件包所要包含的文件列表等等。用户得到了软件包并在系统中执行特定的命令后，软件包会根据内部的脚本检测需要的软件包是否存在。
在安装完成后安装工具还会将安装信息写入软件管理机制工今后升级。删除，查询，验证。
以rpm为例
```
rpm -ivh <rpm 软件包名> 安装
rpm -qa xx 查找rpm包
rpm -ql <rpm包名> 查找某组件想系统写入的文件列表
rpm -e <rpm 软件名> 卸载
```
`rpm`在安装之前为了避免被错误安装，会先肩擦哈系统的硬盘容量，操作系统版本等。所以RPM必须要在相同的Linux环境下才能安装。有些软件作者出了提供`rpm`还有`srpm`格式。它提供了参数配置档，即`configure`与`makefile`。

#### 线上升级
rpm和dpkg这些机制并没有完全解决属性相依的问题。通过线上升级的方式可以解决这些问题。
这种策略的实施过程是系统先制作这些相依属性的软件列表，在安装某个软件包的时候，先到这个列表查找，同时与系统内已安装的软件相比较。这样没安装的相依软件就能一次性全部安装起来。
yum是用Python写的，所以升级Python要谨慎。

## 磁盘的管理方式
FAT32（File Allocate Table）是windows95 时代开始使用的文件系统。NTFS是微软为NT系统设计的。
Linux下的文件系统是ExtN（N = 2，3，4）
ExtN文件系统必定包含inode数据结构来代表一个文件。并且存储这个文件的各种属性和权限。至于实际的数据则放在data block区块中。
data block与inode每个都有一个唯一的编号。inode只需要记录这些编号，就能够定位整个文件的任意一段数据。采用这种数据存取方式的文件系统被称为索引式文件系统。
相对于对于FAT32，ExtN几乎没有磁盘碎片问题。因为可以一次性获得所有的data block块位置，进而可以调整读取顺序，保证了磁盘可以在一圈之内读取全部数据。
#### 磁盘的基本操作
* df
用于查看系统中所有磁盘的整体使用量。此时显示的Filesystem被称为磁盘分区更合适，之所以叫他文件系统，是因为每一个磁盘分区都是一个文件系统的具体实例。
在/dev目录下的所有文件都与一个具体的设备有关系，有物理的，也有虚拟的，而sda1就是一个物理设备，它对应系统第一块串口硬盘的第一个分区。
`/dev/mapper/*`下这些是虚拟的设备，它实际上是逻辑卷。
最奇怪的是Filesystem下对应的tmpfs，这个设备文件其实不存在，因为他不对应任何设备，它实际上是真正的文件系统名称，而这个文件系统是在内存中虚拟的，与具体的硬盘无关，所以也就没有具体的设备，于是在df的输出中，就索性使用类名称代替了。这样的特种文件系统还有好多，如`procfs`，`sysfs`。
* du
df命令是用来观察你磁盘的总体使用量的，要观察局部使用量，需要使用du命令。df命令可以通过读取磁盘的super block实现。而du命令要搜索所有的inode来计算。
* dd
从严格意义上来讲，dd命令不应该数据管理磁盘的命令，但是你如果想直接读写磁盘的每一个扇区或者镜像整个磁盘，dd命令会是个非常好的选择。
```
dd if=input_file of=output_file
dd if=/etc/bashrc of=./bashrc 等价于 cp /etc/bashrc ./bashrc
```
若不给出if、of，则默认是标准输入输出设备
所以可以使用`dd if=/etc/bashrc`模拟`cat`
`dd if=/dev/sda1 of=./sda1.img`可以备份第一个分区
压缩一下
`dd if=/dev/sda1 | gzip -9 > ./sda1.img`
恢复
`gzip -dc ./sda.img | dd of=/dev/sda`
它还可以指定读写数据量，通过bs和count这两个参数指定一次读写的字节和读写的次数。比如备份主引导记录。
`dd if=/dev/sda of=./mbr.img bs=512 count=1`
`dd`还可以干好多事情
`dd if=/dev/urandom of=/dev/sda`
`dd if=/dev/zero of=./test.file bs=1024 count=1000000`
`dd if=./test.file bs=8k | dd of=/dev/null`
`dd if=/dev/sda of=/dev/sda`
其中有`/dev/urandom`、`/dev/zero`（主要面对读）、`/dev/null`（主要面对写）这几个特殊的设备文件。
* fsck
很少手工执行，基本是在系统启动阶段就执行了，它的作用和windows下的scandisk一样，对文件系统的损坏进行修复。
`fsck -f -t ext3 /dev/sda3`强制检查，否则在没有报错的磁盘中是不会做文件检查的。
* mount
`mount [-t 文件系统] 设备名称 挂载点`
`mount -t vfat /dev/sdb /data`
很多时候`t`参数是多余的，因为类似Ext2、Ext3、Ext4这样的ExtN类的基于inode的文件系统都是有超级块的。利用超级快就能了解到具体的文件系统。第二种方法多用于挂在Windows分区时使用
如果有一个实际的文件系统中的内容，与在某个磁盘设备中能够读到的内容一致，那么这个实际的文件也能够被挂载进来。
`mount -o loop ./sda1.img /mnt/sda1`
第一个参数`-o`:`ro`只读`rw`可读可写
loop代表这是一个环形设备，如硬盘、光盘

`umount [设备名或挂载目录]`
`umount /data`
`umount /dev/sdb`

#### 交换分区
交换分区等同于windows下的页面文件。所谓的页面交换文件，实际上就是虚拟内存管理时要使用的内存置换文件，那就是用来拓展虚拟内存空间的。
`fdisk`创建减缓分区
`mkswap`格式化交换分区，可以选择将一个文件格式化为交换分区格式，然后挂载
`swapon`挂载交换分区
`swapoff`卸载交换分区

#### 逻辑卷
逻辑卷能够弹性的调整文件系统的容量。
从理论上说，逻辑卷就是在磁盘分区和文件系统之间增加了一个逻辑层。
这样当文件系统的容量觉得不够用时，可以向逻辑卷中增加新的分区来实现扩大容量
从理论上来说，逻辑卷就是在磁盘分区和文件系统之间增加了一个逻辑层，
这样，当文件系统的容量觉得不够用时，可以向逻辑卷中增加新的分区来实现扩大容量的目的。

## 上网问题
