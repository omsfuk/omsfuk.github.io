-----------------------
title: Java特种兵 之 内存
tags: java
-----------------------
# 概述
*  内存就是跑程序的地方。

*  内存是磁盘存储与CPU之间的一座“缓冲区桥梁”，它与CPU通信的速度是磁盘的千倍以上，它几乎没有IOPS（每秒读写次数）的概念。宽带也是几十G每秒，从容量上来讲，他拥有比CPU的缓存大出几百倍、几千倍的空间来存储程序和数据，现代的PC上大多也已经是8G、16G或者更高配置在运行系统，内存的大小在一些场景下可以决定计算机的整体能力。

*  CPU的Cache大小虽然也在不断变大，但目前来讲都是以MB为单位，目前最大的三级缓存大小也不过几十MB（一级缓存和二级缓存相对较小），如果缓存变得过大，又会像内存那样涉及各种复杂的算法来管理了。

## 物理地址、逻辑地址、虚拟地址与线性地址
*  以32为模式下的OS为例：最基础的是物理地址，系统会为每个内存单元编写一些物理地址（它是地址总线上的对应关系，每个地址位的0|1都可以表达出不同的地址），物理地址可以认为是唯一的，它由内存本身的电路来控制。
所有的“程序中”使用的地址都是虚拟地址（在段式管理中也叫逻辑地址），这些地址在不同的进程之间是可以重复的，所以才叫虚拟地址。此时小伙伴们回想：通过虚拟地址如何找到物理地址呢？  
*  Tips：在程序中为什么要使用虚拟地址呢？用过C代码的同学都知道，在编译后的指令中，许多调用的地址在编译阶段就得确定下来，许多方法入口和变量位置在编译时确定了虚拟地址，而真正运行时是要由OS来分配实际的地址给程序的。  
*  另外，使用虚拟地址后，地址是可以被复用的，程序并不关注其他的进程是否会用同一个地址（这一点由OS分配时来确保），而只关注自己的进程可以用这个地址。
如果没有使用分页机制，那么每个程序会有一个“段”的概念，也就是为进程分配的一段内存区，它的起始位置+逻辑位置（此时逻辑地址就像偏移量一样）得到线性地址，而此时由于每个程序段是单独的一块连续区域，因此线性地址就是物理地址。
*  若一个进程访问的不是“本进程的内存”，那么就会出现问题，在Windows上写C程序遇到这种情况会提示“内存不能为read”等错误，进程可能会被crash掉。
*  线代CPU启动了分页模型，以支撑较大的内存，分页模型会将内存区域划分为较小的页，物理上大多将其划分为4KB/页，要管理这些页就需要一些管理者。下面来看大概的情况。
*  系统会为每个进程分配页目录，这个页目录也是一个页（大小也是4KB），这些页是由Kernel（内核）来管理的（因此Kernel需要单独的区域，程序所使用地址并不是从0开始的），当通过一个虚拟地址访问内存时，会寻找对应进程的页目录的地址，加载到CR3寄存器（控制寄存器）中。
*  找到页目录后做什么呢？页目录是4KB大小，在32位系统中，每4字节可以存放一个地址，可以存放0~1023共1024个地址，因此传入的逻辑地址只需要10位就可以定位到一个页目录中一个保存地址的单元（32位中的高10位），这个单元存储的地址就是“页表”的地址。

*  在64位系统中，面对大内存（例如500GB），页目录也会变得十分大，此时某些解决方案是增加层次，也就是在页管理上增加层次或采用大页内存来降低页数量，那么访问自然会变慢一点。所以64位系统的程序未必就一定比32位跑得好。

*  当一个进程需要申请“一次”分配内存时，操作系统会分配一块连续的虚拟地址内存给它。当然，进程可以多次向操作系统申请内存空间，这些空间最终和进程所对应的页目录映射起来，所以当进程退出后，这些资源都会被释放。

*  在Java语言中，主要是看Heap区域，当系统参数设置为-Xms、-Xmx时，JVM通常是申请一个连续的虚拟地址，也就是Java申请一块大内存，通过OS预先分配的实际物理内存空间是-Xms的大小，但是OS未必会立即分配一个-Xmx大小的空间给JVM使用，许多空间也是到真正使用时才分配的。

*  线性地址分配好以后，自己来虚拟分配内存空间，对象分配内存时由JVM与OS交互来完成，这个分配可能会比C语言在分配内存上更加简单。但也正因为如此，JVM的内存空间需要由自己来释放，因为这些地址相对OS来讲都已经给JVM了，它并不知道什么时候会释放这部分内存空间。

*  而JVM这块大内存要求逻辑地址是连续的，所以会比较苛刻，通常在32位系统中，由于OS会被占用一部分内存空间，通常JVM的内存空间不会被设置的太大，当设置太大时，会提示无法分配内存的错误。
在32位系统中，1.5GB的Heap区域是比较合适的，因为JVM除了这部分空间外还需要使用很多空间，必须为这些开销预留空间。在64位系统中，这个空间几乎不受限制，不过这是JVM也必须换64位模式的。

