-----------------------
title: Java特种兵 之 硬盘
tags: java
-----------------------

# 综述
*  磁盘自存在以来，一直拖着计算机的后腿，发展停滞不前，小的创新没有带来质的飞跃，知道SSD磁盘问世。
SSD硬盘存在的灵感来自于“磁带”（磁带是最便宜、密度最大的顺序存储设备），也就是“机械刻录”和“机械读取”，它发展这么多年来，一直以：提高转速、增加盘片来提升单盘速度，通过尺寸大小、阵列、冗余等方法来提高容量和稳定性，即使是高端存储也离不开这些原理（只是做了更多的冗余、更多的缓存设备、更多的策略与算法来提高性能和保证数据不丢失）。但是由于磁盘本身的磁头原理所限制，磁盘本身的效率一直不高。

*  直到最近几年，随着SSD硬盘的问世，IOPS的概念逐渐变成了“笑话”，许多优化算法也瞬间被秒杀。SSD硬盘采用了很多内存的设计原理，而非机械硬盘的转盘思想，可以实现多通道读/写操作，IOPS开始有了”飞一般的感觉“。SSD硬盘本身的访问性能可以说已经十分高了，不过由于接口大多还是SATA，在传统机型的配置上SSD硬盘的性能一直达不到它本身的极限，但也已经远远超越了机械硬盘几十倍甚至上百倍（对于SSD硬盘，已经有PCIE Express的标准正在制定，未来硬盘可能会和内存一样接近CPU，那又将是计算机的一次革命，所以技术永远在变化，跟得上时代才是最重要的）。

*  Tips：IOPS：磁盘每秒最多可以完成的I/O次数。这个I/O大家不要理解为一次做大量数据处理的读/写I/O，一般是指小I/O，很大的数据读/写也通常会被分解为多次小的I/O读/写来操作。
随机读/写：这是一个相对的概念，磁盘本身在每次发生读/写操作的过程中，需要寻找位置再进行读/写操作。由于频繁的发生磁盘小I/O请求（例如4KB），所以就频繁地寻找位置，就像是随机读写。

# 机械硬盘基本原理
*  硬盘，用于存储数据，存储空间十分庞大，比内存大得多，而且他在断电的时候不会丢失数据，所以存储在硬盘上的数据又叫持久化数据。

*  加载程序也需要从硬盘中读取，它是在进程启动时被加载的（有些语言也会按需加载，但程序所占用的空间本身不会太多，这部分问题不大。在程序中做得最多的是对数据的读写操作，数据读/写就是I/O，机械硬盘与内存通信，一般很多硬件架构中的信息还会经过“南桥”（South Bridge）再到“北桥”（North Bridge），传送过程中的通信带宽被大大降低。
*  不过，对于机械硬盘来讲，效率低的原因不是带宽，而是IOPS也就是机械硬盘“本身的读写效率”。那么机械硬盘到底如何读/写数据呢？

*  当硬盘找到数据后，前面提到加载4KB和加载1MB数据的时间差别并不大，所以往往许多小的I/O就是KB级别的，会不断地随机读写硬盘，不断地寻道和寻址，那么自然在每次I/O时都会有这样的延迟。因此，在随机I/O操作比较多的系统中，IOPS成为其重要的量化标准。

*  使用多个盘片并不会提高IOPS。这样的方式对于顺序读/写的操作，可以加快读取的速度，而对于随机读/写似乎作用不大（因为大量的随机读/写将导致大量的I/O请求，而每次请求都会存在摆头定位磁道及旋转到指定位置的延迟。

*  硬盘这么慢，能支持全世界的“商业数据”及“互联网数据”这么多年，靠的就是阵列、存储厂商提供的各类大型存储设备。阵列就是大家常说的“RAID”，它就是一张卡，相当于一层硬盘的代理。有很多种RAID方式，现在做得最多的就是RAID 5和RAID 10。
*  RAID 5可以实现硬盘负载均衡，并且可以在坏掉任意一块硬盘的情况下，将内容进行恢复，但是不能坏掉两块或更多的硬盘（如果有3块硬盘做RAID5，那么比一块硬盘的读/写性能理论上提升1倍，其中任意一块坏掉，都可以通过另外两块找回数据）。
*  RAID 10可以实现一半硬盘的负载均衡效率，每一块硬盘都有一块冗余的硬盘和它存储一样的数据（读操作访问其中任意一块都可以）。在这种情况下，只要不是相邻备份的两块硬盘“同时”坏掉，就不会丢失任何数据。

# SSD的一些应用拓展
*  SSD是近几年问世的，它算是传统硬盘的一个终结者。
*  SSD问世后，瞬间秒杀许多公司多年来的技术储备。尤其是许多大型存储厂商瞬间感觉到了压力，因为它的IOPS能力超越传统硬盘上百倍甚至上千倍。现在在很多服务器上拖后腿的是一些接口带宽和架构本身的限制，因此大家也在极力去改变现状。
*  SSD硬盘的问世，改变了很多硬盘厂商、存储底层程序设计者、DBA的理论和经验，乃至颠覆了很多应用程序设计人员对于存储认识的初衷。

# 在Java程序中使用磁盘吗
*  通常程序和磁盘打交道的就是写日志较多，通过网络I/O让数据库访问磁盘也间接地算是一种硬盘操作。
当然，数据库一般由一个DBA来关注它的实现，而开发者需要懂得你写的SQL大概对I/O有多大的影响，因为系统的瓶颈会在这里。

*  而对于硬盘本身，拿日志来讲，许多日志写工具，会将日志替换为Buffer的append方式，它将日志写入一个缓冲区中，由专门的程序来实现日志写操作，或者写的时候发现缓冲区已满，则本次写入磁盘。这样一来，一次写入多条数据，每次写入量就开始变大，也就是将随机I/O逐渐变成顺序I/O操作（将多次硬盘寻道、寻址“尽量”变成一次）。
*  Tips：所谓“尽量”当然就是“不确保”，一个原因是磁盘上可能有磁盘碎片会导致重新寻址，所以碎片清理也很重要。
*  另外是Buffer多大的问题，多大的Buffer一次写入磁盘时也并非是一次性写入的，而且过大的Buffer会占用JVM的内存空间，长期占有或过大就会占有Old区域的空间。使得它更容易做FULL GC。因此，在有些问题的考虑上，我们也不能过分强求，关键是要找到契合点。


